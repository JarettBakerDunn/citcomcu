#!/usr/bin/env python
""" 
    This script auto-generates the function prototypes for all the
    C source files in the current directory, except for two files
    (Citcom.c and Obsolete.c). The actual parsing is done by an 
    external tool called cproto, which may be obtained from the
    following url:
    
        http://cproto.sourceforge.net/

    Note that any lines between the BEGIN and END comments will be
    preserved (except for any leading or trailing whitespace).
    You must keep the relative position of those two comments, i.e.,
    between the header guard and the function prototypes.
"""
import os, re, glob


# location of cproto executable
cproto = '/usr/bin/cproto'

# cproto options:
#   -q      omit error messages from missing #include's
#   -p      disable promotions in parameter list (char -> int, ...)
#   -f 3    verbose style
options = '-q -p -f 3'


# String template for the contents of the generated header file.
template = """\
%(copyright)s

%(warning)s

#ifndef %(guard)s
#define %(guard)s

/** BEGIN **/
%(section)s
/** END **/

%(prototypes)s
/* cproto command: %(command)s */
#endif
"""


warning_default = """
/***********************************************************************
 *                                                                     *
 * WARNING: This file is auto-generated by the script `prototypes.py'. *
 *                                                                     *
 * Since the function prototypes can be generated, you should modify   *
 * the function definitions instead. You can then use the script to    *
 * keep the headers up to date.                                        *
 *                                                                     *
 * You can add (almost) anything you want in the section between the   *
 * BEGIN and END comments and it will be preserved.  Anything outside  *
 * those comments will be overwritten in the next pass.                *
 *                                                                     *
 * Ignore this warning if you will be maintaining this file manually   *
 * from now on.                                                        *
 *                                                                     *
 ***********************************************************************/
"""


section_regexp  = r'/\*\* BEGIN \*\*/(.*)/\*\* END \*\*/'
section_pattern = re.compile(section_regexp, re.DOTALL)
section_default = '''\
#include "element_definitions.h"
#include "global_defs.h"'''


copyright = """\
/*
 * CitcomCU is a Finite Element Code that solves for thermochemical
 * convection within a three dimensional domain appropriate for convection
 * within the Earth's mantle. Cartesian and regional-spherical geometries
 * are implemented. See the file README contained with this distribution
 * for further details.
 * 
 * Copyright (C) 1994-2005 California Institute of Technology
 * Copyright (C) 2000-2005 The University of Colorado
 *
 * Authors: Louis Moresi, Shijie Zhong, and Michael Gurnis
 *
 * For questions or comments regarding this software, you may contact
 *
 *     Luis Armendariz <luis@geodynamics.org>
 *     http://geodynamics.org
 *     Computational Infrastructure for Geodynamics (CIG)
 *     California Institute of Technology
 *     2750 East Washington Blvd, Suite 210
 *     Pasadena, CA 91007
 *
 * This program is free software; you can redistribute it and/or modify 
 * it under the terms of the GNU General Public License as published by 
 * the Free Software Foundation, either version 2 of the License, or any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with this program; if not, write to the Free Software 
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */"""


def get_command(source):
    """Returns the command to be executed on a given source file"""
    return '%(exe)s %(opts)s %(source)s' % {
            'exe'    : cproto,
            'opts'   : options,
            'source' : source }

def get_header(source):
    """Given a source file, replace the .c extension with .h"""
    return source.replace('.c','.h')

def get_warning():
    """Returns a warning for the auto-generated file."""
    return warning_default

def get_guard(header):
    """
    Given a header filename, return an appropriate guard string,
    for use in preventing multiple #includes of the header file.
    """
    return "__%s__" % header.replace('.','_').upper()

def get_section(header):
    """
    Given a header file, parse the text between the
    BEGIN and END comments and return it as the section text.
    Note that leading and trailing whitespace characters are
    stripped.
    """
    if os.path.exists(header):
        try:
            file = open(header, 'r')
            contents = file.read()
            match = section_pattern.search(contents)
            file.close()
            if match:
                return match.group(1).strip()
        except IOError:
            pass
    return section_default


def main():
    sources = glob.glob('*.c')
    sources.remove('Citcom.c')
    sources.remove('Obsolete.c')
    for source in sources:
        # determine the header filename
        header  = get_header(source)
        warning = get_warning()
        guard   = get_guard(header)
        section = get_section(header)
        # run the command and capture its stdout
        command = get_command(source)
        pipe = os.popen3(command, 'r')
        prototypes = pipe[1].read()
        print '%s' % command
        # fill in the template and save to file
        file = open(header, 'w')
        file.write(template % {
            'copyright'  : copyright,
            'warning'    : warning,
            'guard'      : guard,
            'section'    : section,
            'prototypes' : prototypes,
            'command'    : command,
        })
        file.close()


if __name__ == '__main__':
    main()
